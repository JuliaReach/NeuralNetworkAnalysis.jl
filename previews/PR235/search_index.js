var documenterSearchIndex = {"docs":
[{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Airplane/Airplane.jl\"","category":"page"},{"location":"models/Airplane/#Airplane","page":"Airplane","title":"Airplane","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"(Image: )","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"This example consists of a dynamical system that is a simple model of a flying airplane. There are 12 state variables:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginaligned\nx y z u v w ϕ θ ψ r p q\nendaligned","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"where (x y z) is the position of the center of gravity (C.G.), (u v w) are the components of velocity in (x y z) directions, (p q r) are body rotation rates, and (ϕ θ ψ) are the Euler angles.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"See also the file airplane.png for a visualization of the meaning of the coordinates with respect to the airplane.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"using NeuralNetworkAnalysis\nusing NeuralNetworkAnalysis: SingleEntryVector","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The following option determines whether the falsification settings should be used or not. The falsification settings are sufficient to show that the safety property is violated. Concretely we start from an initial point and use a smaller time step.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"const falsification = true;\nnothing #hide","category":"page"},{"location":"models/Airplane/#Model","page":"Airplane","title":"Model","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The equations of motion are reduced to:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"left beginarraylcl\nu =  g sin(theta) + fracF_xm - qw + rv \nv = g cos(theta) sin(phi) + fracF_ym - ru + pw \nẇ = g cos(theta) cos(phi) + fracF_zm - pv + qu \nI_x dot p + I_xz dot r = M_x - (I_z - I_y) qr - I_xz pq \nI_y dot q = M_y - I_xz(r^2 - p^2) - (I_x - I_z) pr \nI_xz dot p + I_z dot r = M_z - (I_y - I_x) qp - I_xz rq\nendarray right","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The mass of the airplane is denoted with m and I_x , I_y , I_z and I_xz are the moment of inertia with respect to the indicated axis. The control parameters include three force components F_x , F_y and F_z and three moment components M_x , M_y , M_z . Notice that for simplicity we have assumed the aerodynamic forces are absorbed in the F's. In addition to these six equations, we have six additional kinematic equations:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginbmatrix\ndot x  dot y  dot z\nendbmatrix\n=\nbeginbmatrix\ncos(psi)  -sin(psi)  0 \nsin(psi)  cos(psi)  0 \n0  0  1\nendbmatrix\nbeginbmatrix\ncos(theta)  0  sin(theta) \n0  1  0 \n-sin(theta)  0  cos(theta)\nendbmatrix\nbeginbmatrix\n1  0  0 \n0  cos(phi)  -sin(phi) \n0  sin(phi)  cos(phi)\nendbmatrix","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"and","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginbmatrix\nphi  theta  psi\nendbmatrix\n=\nbeginbmatrix\n1  tan(theta) sin(phi)  tan(theta) cos(phi) \n0  cos(phi)  -sin(phi) \n0  sec(theta) sin(phi)  sec(theta) cos(phi)\nendbmatrix\nbeginbmatrix\np  q  r\nendbmatrix","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"For the simplicity of control design, the parameters have been chosen to have some nominal dimensionless values: m = 1, I_x = I_y = I_z = 1, I_xz = 0 and g = 1.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Tψ = ψ -> [cos(ψ)  -sin(ψ)  0;\n           sin(ψ)   cos(ψ)  0;\n                0        0  1]\n\nTθ = θ -> [ cos(θ)  0  sin(θ);\n                 0  1       0;\n           -sin(θ)  0  cos(θ)]\n\nTϕ = ϕ -> [1       0        0;\n           0  cos(ϕ)  -sin(ϕ);\n           0  sin(ϕ)   cos(ϕ)]\n\nRϕθ = (ϕ, θ) -> [1  tan(θ) * sin(ϕ)  tan(θ) * cos(ϕ);\n                 0           cos(θ)          -sin(ϕ);\n                 0  sec(θ) * sin(ϕ)  sec(θ) * cos(ϕ)]\n\n# alternative matrix with only sin/cos but with postprocessing\n# Rϕθ_ = (ϕ, θ) -> [cos(θ)  sin(θ) * sin(ϕ)   sin(θ) * cos(ϕ);\n#                        0  cos(θ) * cos(ϕ)  -cos(θ) * sin(ϕ);\n#                        0           sin(ϕ)            cos(ϕ)]\n\n# model constants\nconst m = 1.0\nconst g = 1.0\n\n# unused constants (terms are simplified instead)\nconst Ix = 1.0\nconst Iy = 1.0\nconst Iz = 1.0\nconst Ixz = 0.0\n\n@taylorize function airplane!(dx, x, p, t)\n    _x, y, z, u, v, w, ϕ, θ, ψ, r, _p, q, Fx, Fy, Fz, Mx, My, Mz = x\n\n    T_ψ = Tψ(ψ)\n    T_θ = Tθ(θ)\n    T_ϕ = Tϕ(ϕ)\n    mat_1 = T_ψ * T_θ * T_ϕ\n    xyz = mat_1 * vcat(u, v, w)\n\n    mat_2 = Rϕθ(ϕ, θ)\n    # mat_2 = 1 / cos(θ) * Rϕθ_(ϕ, θ)  # alternative matrix with postprocessing\n    ϕθψ = mat_2 * vcat(_p, q, r)\n\n    dx[1] = xyz[1]\n    dx[2] = xyz[2]\n    dx[3] = xyz[3]\n    dx[4] = -g * sin(θ) + Fx / m - q * w + r * v\n    dx[5] = g * cos(θ) * sin(ϕ) + Fy / m - r * u + _p * w\n    dx[6] = g * cos(θ) * cos(ϕ) + Fz / m - _p * v + q * u\n    dx[7] = ϕθψ[1]\n    dx[8] = ϕθψ[2]\n    dx[9] = ϕθψ[3]\n    dx[10] = Mx  # simplified term\n    dx[11] = My  # simplified term\n    dx[12] = Mz  # simplified term\n    dx[13] = zero(Fx)\n    dx[14] = zero(Fy)\n    dx[15] = zero(Fz)\n    dx[16] = zero(Mx)\n    dx[17] = zero(My)\n    dx[18] = zero(Mz)\nend;\nnothing #hide","category":"page"},{"location":"models/Airplane/#Specifications","page":"Airplane","title":"Specifications","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"controller = read_nnet(@modelpath(\"Airplane\", \"controller_airplane.nnet\"))\n\nX₀ = Hyperrectangle(low=[0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    high=[0.0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0])\nif falsification\n    # choose a single point in the initial states (here: the top-most one)\n    X₀ = Singleton(high(X₀))\nend\nU₀ = ZeroSet(6)\n\nvars_idx = Dict(:state_vars=>1:12, :control_vars=>13:18)\nivp = @ivp(x' = airplane!(x), dim: 18, x(0) ∈ X₀ × U₀)\n\nperiod = 0.1  # control period\n\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Safety specification: x_2 should be in 05 05 and x_7 x_8 x_9 should be in -1 1.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"if falsification\n    k = 4  # falsification can run for a shorter time horizon\nelse\n    k = 20\nend\nT = k * period  # time horizon\n\nsafe_states = HPolyhedron([HalfSpace(SingleEntryVector(2, 18, 1.0), 0.5),\n                           HalfSpace(SingleEntryVector(2, 18, -1.0), 0.5),\n                           HalfSpace(SingleEntryVector(7, 18, 1.0), 1.0),\n                           HalfSpace(SingleEntryVector(7, 18, -1.0), 1.0),\n                           HalfSpace(SingleEntryVector(8, 18, 1.0), 1.0),\n                           HalfSpace(SingleEntryVector(8, 18, -1.0), 1.0),\n                           HalfSpace(SingleEntryVector(9, 18, 1.0), 1.0),\n                           HalfSpace(SingleEntryVector(9, 18, -1.0), 1.0)])\n\n# property for guaranteed violation\npredicate = X -> isdisjoint(overapproximate(X, Hyperrectangle), safe_states)\npredicate_sol = sol -> any(predicate(R) for F in sol for R in F);\nnothing #hide","category":"page"},{"location":"models/Airplane/#Results","page":"Airplane","title":"Results","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"import DifferentialEquations\n\nalg = TMJets(abstol=1e-10, orderT=7, orderQ=1)\nalg_nn = Ai2()\n\nfunction benchmark(; silent::Bool=false)\n    # We solve the controlled system:\n    silent || println(\"flowpipe construction\")\n    res_sol = @timed solve(prob, T=T, alg_nn=alg_nn, alg=alg)\n    sol = res_sol.value\n    silent || print_timed(res_sol)\n\n    # Next we check the property for an overapproximated flowpipe:\n    silent || println(\"property checking\")\n    solz = overapproximate(sol, Zonotope)\n    res_pred = @timed predicate_sol(solz)\n    silent || print_timed(res_pred)\n    if res_pred.value\n        silent || println(\"The property is violated.\")\n    else\n        silent || println(\"The property may be satisfied.\")\n    end\n\n    # We also compute some simulations:\n    silent || println(\"simulation\")\n    trajectories = falsification ? 1 : 50\n    res_sim = @timed simulate(prob, T=T, trajectories=trajectories,\n                              include_vertices=!falsification)\n    sim = res_sim.value\n    silent || print_timed(res_sim)\n\n    return solz, sim\nend\n\nbenchmark(silent=true)  # warm-up\nres = @timed benchmark()  # benchmark\nsol, sim = res.value\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Finally we plot the results:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"using Plots\nimport DisplayAs\n\n# set more precise tolerance for plotting small sets correctly\nLazySets.set_ztol(Float64, 1e-9)\n\nfunction plot_helper(fig, vars)\n    if vars[1] == 0\n        safe_states_projected = project(safe_states, [vars[2]])\n        time = Interval(0, T)\n        safe_states_projected = cartesian_product(time, safe_states_projected)\n    else\n        safe_states_projected = project(safe_states, vars)\n    end\n    plot!(fig, safe_states_projected, color=:lightgreen, lab=\"safe states\")\n    if !falsification && 0 ∉ vars\n        plot!(fig, project(initial_state(prob), vars), lab=\"X₀\")\n    end\n    plot!(fig, sol, vars=vars, color=:yellow, lab=\"\")\n    lab_sim = falsification ? \"simulation\" : \"\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    fig = DisplayAs.Text(DisplayAs.PNG(fig))\nend\n\nvars = (2, 7)\nfig = plot(xlab=\"y\", ylab=\"ϕ\", leg=:bottomleft)\nfig = plot_helper(fig, vars)\nif falsification\n    xlims!(-0.01, 0.65)\n    ylims!(0.9, 1.01)\nelse\n    xlims!(-1.8, 22.5)\n    ylims!(-1.05, 1.05)\nend\n# savefig(\"Airplane-x2-x7.png\")\nfig","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"vars = (8, 9)\nfig = plot(xlab=\"θ\", ylab=\"ψ\", leg=:bottom)\nfig = plot_helper(fig, vars)\nif falsification\n    xlims!(0.999, 1.03)\n    ylims!(0.99, 1.001)\nelse\n    xlims!(-1.05, 1.2)\n    ylims!(-1.05, 1.2)\nend\n# savefig(\"Airplane-x8-x9.png\")\nfig","category":"page"},{"location":"lib/utils/","page":"Utilities","title":"Utilities","text":"DocTestSetup = :(using NeuralNetworkAnalysis)\nCurrentModule = NeuralNetworkAnalysis","category":"page"},{"location":"lib/utils/#Utility-functions","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"lib/utils/#Locating-files","page":"Utilities","title":"Locating files","text":"","category":"section"},{"location":"lib/utils/","page":"Utilities","title":"Utilities","text":"@modelpath","category":"page"},{"location":"lib/utils/#NeuralNetworkAnalysis.@modelpath","page":"Utilities","title":"NeuralNetworkAnalysis.@modelpath","text":"@modelpath(name)\n\nReturn the absolute path to file name relative to the executing script.\n\nInput\n\nmodel_path – folder name (ignored by default)\nname       – filename\n\nOutput\n\nA string.\n\nNotes\n\nThis macro is equivalent to joinpath(@__DIR__, name). The @modelpath macro is used in model scripts to load data files relative to the location of the model, without having to change the directory of the Julia session. For instance, suppose that the folder /home/projects/models contains the script my_model.jl, and suppose that the data file my_data.dat located in the same directory is required to be loaded by my_model.jl. Then,\n\n# suppose the working directory is /home/julia/ and so we ran the script as\n# julia -e \"include(\"../projects/models/my_model.jl\")\"\n# in the model file /home/projects/models/my_model.jl we write:\nd = open(@modelpath(\"\", \"my_data.dat\"))\n# do stuff with d\n\nIn this example, the macro @modelpath(\"\", \"my_data.dat\") evaluates to the string /home/projects/models/my_data.dat. If the script my_model.jl only had d = open(\"my_data.dat\"), without @modelpath, this command would fail as julia would have looked for my_data.dat in the working directory, resulting in an error that the file /home/julia/my_data.dat is not found.\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#Reading-networks","page":"Utilities","title":"Reading networks","text":"","category":"section"},{"location":"lib/utils/","page":"Utilities","title":"Utilities","text":"read_nnet_mat\nread_nnet_yaml","category":"page"},{"location":"lib/utils/#NeuralNetworkAnalysis.read_nnet_mat","page":"Utilities","title":"NeuralNetworkAnalysis.read_nnet_mat","text":"read_nnet_mat(file; key=nothing, act_key=\"activation_fcns\")\n\nRead a neural network stored in a .mat file and return the corresponding network in the format of NeuralVerification.jl.\n\nInput\n\nfile    – string indicating the location of the .mat file containing the neural network\nkey     – (optional, default: nothing) key used to search the dictionary containing the controller;              by default we search the top-level dictionary; a typical value is \"controller\"\nact_key – (optional, default: \"activation_fcns\") key used to search the activation              functions; typical values are \"activation_fcns\" or \"act_fcns\"\n\nOutput\n\nA Network struct.\n\nNotes\n\nThe following activation functions are supported:\n\nRELU: \"relu\" (ReLU)\nIdentity: \"linear\" (Id)\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#NeuralNetworkAnalysis.read_nnet_yaml","page":"Utilities","title":"NeuralNetworkAnalysis.read_nnet_yaml","text":"read_nnet_yaml(data::Dict)\n\nRead a neural network from a file in YAML format (see YAML.jl) and convert it\n\nRead a neural network stored in a .mat file and return the corresponding network in the format of NeuralVerification.jl.\n\nInput\n\nfile – string indicating the location of the .mat file containing the neural network\nkey  – (optional, default: \"controller\") key used to search the dictionary\n\nOutput\n\nA Network struct.\n\nNotes\n\nThe following activation functions are supported: identity, relu, sigmoid and tanh; see NeuralNetworkAnalysis.ACT_YAML.\n\n\n\n\n\n","category":"function"},{"location":"lib/problems/","page":"Problem types","title":"Problem types","text":"DocTestSetup = :(using NeuralNetworkAnalysis)\nCurrentModule = NeuralNetworkAnalysis","category":"page"},{"location":"lib/problems/#Problem-types","page":"Problem types","title":"Problem types","text":"","category":"section"},{"location":"lib/problems/#Closed-loop-system","page":"Problem types","title":"Closed-loop system","text":"","category":"section"},{"location":"lib/problems/","page":"Problem types","title":"Problem types","text":"ControlledPlant","category":"page"},{"location":"lib/problems/#NeuralNetworkAnalysis.ControlledPlant","page":"Problem types","title":"NeuralNetworkAnalysis.ControlledPlant","text":"ControlledPlant{ST, CT, XT, DT, PT, CPRT, CPST} <: AbstractControlProblem\n\nStruct representing a closed-loop controlled system.\n\nFields\n\nivp            – initial-value problem\ncontroller     – controller\nvars           – dictionary storing state variables, input variables and                     control variables\nperiod         – control period\npostprocessing – postprocessing of the controller output\npreprocessing  – preprocessing of the controller input\n\nParameters\n\nST:  type of system\nCT:  type of controller\nXT:  type of initial condition\nDT:  type of variables\nPT:  type of period\nCPRT: type of control preprocessing\nCPST: type of control postprocessing\n\nNotes\n\nWhile typically the controller is a neural network, this struct does not prescribe the type.\n\n\n\n\n\n","category":"type"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Single-Pendulum/Single-Pendulum.jl\"","category":"page"},{"location":"models/Single-Pendulum/#Single-Inverted-Pendulum","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"","category":"section"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"(Image: )","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"This is a classical inverted pendulum. A ball of mass m is attached to a massless beam of length L.  The beam is actuated with a torque T and we assume viscous friction exists with a coefficient of c.","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"using NeuralNetworkAnalysis\nusing NeuralNetworkAnalysis: SingleEntryVector","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"The following option determines whether the falsification settings should be used or not. The falsification settings are sufficient to show that the safety property is violated. Concretely we start from an initial point and use a smaller time step.","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"const falsification = true;\nnothing #hide","category":"page"},{"location":"models/Single-Pendulum/#Model","page":"Single Inverted Pendulum","title":"Model","text":"","category":"section"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"The governing equation of motion can be obtained as:","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"ddottheta = dfracgL sin(theta) + dfrac1m L^2 (T - cdottheta)","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"where θ is the angle that the link makes with the upward vertical axis. The state vector is θ θ.","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"model constants","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"const m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g/L\nconst mL = 1/(m*L^2)\n\n@taylorize function single_pendulum!(dx, x, p, t)\n    dx[1] = x[2]\n    dx[2] = gL * sin(x[1]) + mL*(x[3] - c*x[2])\n    dx[3] = zero(x[3])\n    return dx\nend\n\ncontroller = read_nnet(@modelpath(\"Single-Pendulum\",\n                                  \"controller_single_pendulum.nnet\"));\nnothing #hide","category":"page"},{"location":"models/Single-Pendulum/#Specification","page":"Single Inverted Pendulum","title":"Specification","text":"","category":"section"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"The initial set is","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"(theta dottheta) in 1 12 times 0 02","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"The safety specification is that θ  0 1 for all control steps 10  n_t  20.","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"X0 = Hyperrectangle([1.1, 0.1], [0.1, 0.1])\nif falsification\n    # choose a single point in the initial states (here: the top-most one)\n    X0 = Singleton(high(X0))\nend\nU0 = ZeroSet(1)\nivp = @ivp(x' = single_pendulum!(x), dim: 3, x(0) ∈ X0 × U0)\nvars_idx = Dict(:state_vars=>1:2, :control_vars=>3)\n\nperiod = 0.05  # control period\nif falsification\n    k = 11\nelse\n    k = 20\nend\nT = k * period  # time horizon\n\nprob = ControlledPlant(ivp, controller, vars_idx, period)\n\nunsafe_states = HalfSpace(SingleEntryVector(1, 3, -1.0), -1.0)\n\npredicate = X -> overapproximate(X, Hyperrectangle) ⊆ unsafe_states\nfunction predicate_sol(sol; silent::Bool=false)\n    for F in sol\n        for R in F\n            t = tspan(R)\n            if t.lo >= 0.5 && t.hi <= 1.0 && predicate(R)\n                silent || println(\"violation for time range $t\")\n                return true\n            end\n        end\n    end\n    return false\nend;\nnothing #hide","category":"page"},{"location":"models/Single-Pendulum/#Results","page":"Single Inverted Pendulum","title":"Results","text":"","category":"section"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"import DifferentialEquations\n\nalg = TMJets(abstol=1e-7, orderT=4, orderQ=1)\nalg_nn = Ai2()\n\nfunction benchmark(; silent::Bool=false)\n    # We solve the controlled system:\n    silent || println(\"flowpipe construction\")\n    res_sol = @timed solve(prob, T=T, alg_nn=alg_nn, alg=alg)\n    sol = res_sol.value\n    silent || print_timed(res_sol)\n\n    # Next we check the property for an overapproximated flowpipe:\n    silent || println(\"property checking\")\n    solz = overapproximate(sol, Zonotope)\n    res_pred = @timed predicate_sol(solz; silent=silent)\n    silent || print_timed(res_pred)\n    if res_pred.value\n        silent || println(\"The property is violated.\")\n    else\n        silent || println(\"The property may be satisfied.\")\n    end\n\n    # We also compute some simulations:\n    silent || println(\"simulation\")\n    trajectories = falsification ? 1 : 10\n    res_sim = @timed simulate(prob, T=T, trajectories=trajectories,\n                              include_vertices=!falsification)\n    sim = res_sim.value\n    silent || print_timed(res_sim)\n\n    return solz, sim\nend;\n\nbenchmark(silent=true)  # warm-up\nres = @timed benchmark()  # benchmark\nsol, sim = res.value\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"Finally we plot the results:","category":"page"},{"location":"models/Single-Pendulum/","page":"Single Inverted Pendulum","title":"Single Inverted Pendulum","text":"using Plots\nimport DisplayAs\n\nvars = (0, 1)\nfig = plot(ylab=\"θ\")\nunsafe_states_projected = project(unsafe_states, [vars[2]])\ntime = Interval(0.5, 1.0)\nunsafe_states_projected = cartesian_product(time, unsafe_states_projected)\nplot!(fig, unsafe_states_projected, color=:red, alpha=:0.2, lab=\"unsafe states\")\ntime0 = Singleton([0.0])\nif !falsification\n    plot!(fig, cartesian_product(time0, project(initial_state(prob), [vars[2]])),\n          lab=\"X₀\")\nend\nplot!(fig, sol, vars=vars, color=:yellow, lab=\"\")\nif falsification\n    xlims!(0, T)\n    ylims!(0.95, 1.22)\nelse\n    xlims!(0, T)\n    ylims!(0.55, 1.3)\nend\nlab_sim = falsification ? \"simulation\" : \"\"\nplot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(\"Single-Pendulum.png\")\nfig","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Sherlock-Benchmark-10-Unicycle/Sherlock-Benchmark-10-Unicycle.jl\"","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/#Unicycle-Car-Model","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"(Image: )","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"using NeuralNetworkAnalysis\nusing NeuralNetworkAnalysis: UniformAdditivePostprocessing, SingleEntryVector","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"This benchmark is that of a unicycle model of a car [1] taken from Benchmark 10 of the Sherlock tool. It models the dynamics of a car involving 4 variables, specifically the x and y coordinates on a 2 dimensional plane, as well as velocity magnitude (speed) and steering angle.","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/#Model","page":"Unicycle Car Model","title":"Model","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"The model is a four-dimensional system given by the following equations:","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"left beginarraylcl\ndotx_1 = x_4 cos(x_3) \ndotx_2 = x_4 sin(x_3) \ndotx_3 = u_2 \ndotx_4 = u_1 + w\nendarray right","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"where w is a bounded error in the range 1e4 1e4. A neural network controller was trained for this system. The trained network has 1 hidden layer with 500 neurons. Note that the output of the neural network f(x) needs to be normalized in order to obtain (u_1 u_2), namely u_i = f(x)_i  20. The sampling time for this controller is 0.2s.","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"We model the error w as a nondeterministically assigned constant.","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"@taylorize function unicycle!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, w, u₁, u₂ = x\n\n    dx[1] = x₄ * cos(x₃)\n    dx[2] = x₄ * sin(x₃)\n    dx[3] = u₂\n    dx[4] = u₁ + w\n    dx[5] = zero(x[5])\n    dx[6] = zero(x[6])\n    dx[7] = zero(x[7])\n    return dx\nend\n\ncontroller = read_nnet_mat(@modelpath(\"Sherlock-Benchmark-10-Unicycle\",\n                                      \"controllerB_nnv.mat\");\n                           act_key=\"act_fcns\");\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/#Specification","page":"Unicycle Car Model","title":"Specification","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"The verification problem here is that of reachability. For an initial set of, x_1  95955 x_2  45445 x_3  21211 x_4  15151, its is required to prove that the system reaches the set x_1  0606 x_2  0202 x_3  006006 x_4  0303 within a time window of 10s.","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"X₀ = Hyperrectangle(low=[9.5, -4.5, 2.1, 1.5, -1e-4],\n                    high=[9.55, -4.45, 2.11, 1.51, 1e-4])\nU₀ = ZeroSet(2)\nvars_idx = Dict(:state_vars=>1:4, :input_vars=>[5], :control_vars=>6:7)\nivp = @ivp(x' = unicycle!(x), dim: 7, x(0) ∈ X₀ × U₀)\n\nperiod = 0.2  # control period\n\ncontrol_postprocessing = UniformAdditivePostprocessing(-20.0)\n\nprob = ControlledPlant(ivp, controller, vars_idx, period;\n                       postprocessing=control_postprocessing)\n\n# Safety specification: [x[1], x[2], x[3], x[4]] ∈ ±[0.6, 0.2, 0.06, 0.3] for some t ≤ T\nT = 10.0\nT_warmup = 2 * period  # shorter time horizon for dry run\n\ntarget_set = HPolyhedron([HalfSpace(SingleEntryVector(1, 7, 1.0), 0.6),\n                          HalfSpace(SingleEntryVector(1, 7, -1.0), 0.6),\n                          HalfSpace(SingleEntryVector(2, 7, 1.0), 0.2),\n                          HalfSpace(SingleEntryVector(2, 7, -1.0), 0.2),\n                          HalfSpace(SingleEntryVector(3, 7, 1.0), 0.06),\n                          HalfSpace(SingleEntryVector(3, 7, -1.0), 0.06),\n                          HalfSpace(SingleEntryVector(4, 7, 1.0), 0.3),\n                          HalfSpace(SingleEntryVector(4, 7, -1.0), 0.3)])\npredicate = X -> X ⊆ target_set\npredicate_sol = sol -> any(predicate(R) for F in sol for R in F);\n\n# sufficient check: only look at the final time point\npredicate_R_tend = R -> overapproximate(R, Zonotope, tend(R)) ⊆ target_set\npredicate_R_all = R -> R ⊆ target_set\npredicate_sol_suff = sol -> predicate_R_all(sol[end]);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/#Results","page":"Unicycle Car Model","title":"Results","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"alg = TMJets(abstol=1e-15, orderT=10, orderQ=1)\nalg_nn = Ai2()\nsplitter = BoxSplitter([3, 1, 8, 1])\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # We solve the controlled system:\n    silent || println(\"flowpipe construction\")\n    res_sol = @timed sol = solve(prob, T=T, alg_nn=alg_nn, alg=alg,\n                                 splitter=splitter)\n    sol = res_sol.value\n    silent || print_timed(res_sol)\n\n    # Next we check the property for an overapproximated flowpipe:\n    silent || println(\"property checking\")\n    res_pred = @timed predicate_sol_suff(sol)\n    silent || print_timed(res_pred)\n    if res_pred.value\n        silent || println(\"The property is satisfied.\")\n    else\n        silent || println(\"The property may be violated.\")\n    end\n    return sol\nend;\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed sol = benchmark()  # benchmark\nsol = res.value\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"We also compute some simulations:","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"import DifferentialEquations\n\nprintln(\"simulation\")\nres = @timed simulate(prob, T=T; trajectories=10, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"Finally we plot the results:","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"using Plots\nimport DisplayAs\n\nsolz = overapproximate(sol, Zonotope)\nTint = try convert(Int, T) catch; T end\n\nfunction plot_helper(fig, vars; show_simulation::Bool=true)\n    if vars[1] == 0\n        target_set_projected = project(target_set, [vars[2]])\n        time = Interval(0, T)\n        target_set_projected = cartesian_product(time, target_set_projected)\n    else\n        target_set_projected = project(target_set, vars)\n    end\n    plot!(fig, solz, vars=vars, color=:yellow, lab=\"\")\n    plot!(fig, target_set_projected, color=:cyan, alpha=0.5, lab=\"target states\")\n    if show_simulation\n        plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    end\nend\n\nvars = (1, 2)\nfig = plot(xlab=\"x₁\", ylab=\"x₂\")\nplot_helper(fig, vars)\n# savefig(\"Unicycle-x1-x2.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"fig = plot(xlab=\"x₁\", ylab=\"x₂\")\nplot_helper(fig, vars; show_simulation=false)\nxlims!(0, 1)\nylims!(-0.5, 0.5)\nplot!(fig, overapproximate(sol[end], Zonotope, tend(solz[end])), vars=vars,\n      color=:orange, lab=\"reach set at t = $Tint\")\n# savefig(\"Unicycle-close-x1-x2.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"vars=(3, 4)\nfig = plot(xlab=\"x₃\", ylab=\"x₄\", leg=:bottomright)\nplot_helper(fig, vars)\n# savefig(\"Unicycle-x3-x4.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"fig = plot(xlab=\"x₃\", ylab=\"x₄\", leg=:bottomright)\nplot_helper(fig, vars; show_simulation=false)\nxlims!(-0.1, 0.1)\nylims!(-0.4, 0)\nplot!(fig, overapproximate(sol[end], Zonotope, tend(solz[end])), vars=vars,\n      color=:orange, lab=\"reach set at t = $Tint\")\n# savefig(\"Unicycle-close-x3-x4.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Sherlock-Benchmark-10-Unicycle/#References","page":"Unicycle Car Model","title":"References","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-10-Unicycle/","page":"Unicycle Car Model","title":"Unicycle Car Model","text":"[1] Souradeep Dutta, Xin Chen, and Sriram Sankaranarayanan. Reachability analysis for neural feedback systems using regressive polynomial rule inference. In Proceedings of the 22nd ACMInternational Conference on Hybrid Systems: Computation and Control, HSCC 2019, Montreal,QC, Canada, April 16-18, 2019., pages 157–168, 2019.","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Sherlock-Benchmark-7/Sherlock-Benchmark-7.jl\"","category":"page"},{"location":"models/Sherlock-Benchmark-7/#D-system-with-sliding-mode-controller","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"(Image: )","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"The model was first proposed in [YH12], where the authors originally designed a discontinuous sliding mode controller for this system.","category":"page"},{"location":"models/Sherlock-Benchmark-7/#Model","page":"3D system with sliding mode controller","title":"Model","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"The model is a three-dimensional system given by the following equations:","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"beginaligned\ndotx_1 = x_3^3 - x_2 + w \ndotx_2 = x_3 \ndotx_3 = u\nendaligned","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"where w is a bounded error in the range 001 001. A neural network controller was trained for this system, using a model predictive controller as a demonstrator. The trained network had 2 hidden layers, with 300 neurons in the first layer, and 200 in the second layer. The sampling time for this controller was 0.5s.","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"using NeuralNetworkAnalysis","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"The spatial variables are aguemte","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"@taylorize function f!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, w, u = x\n\n    dx[1] = x₃^3 - x₂ + w\n    dx[2] = x₃\n    dx[3] = u\n    dx[4] = zero(x₄) # w\n    dx[5] = zero(x₅) # u\n    return dx\nend","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"define the initial-value problem","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"X₀ = Hyperrectangle(low=[0.35, 0.45, 0.25], high=[0.45, 0.55, 0.35])\nW₀ = Interval(-0.01, 0.01)\nU₀ = Interval(2.0, 2.0)\nprob = @ivp(x' = f!(x), dim: 5, x(0) ∈ X₀ × W₀ × U₀);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"solve it","category":"page"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"##sol = solve(prob, T=2.0);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-7/#Specifications","page":"3D system with sliding mode controller","title":"Specifications","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"The verification problem here is that of target reachability. For an initial set of x₁  035 045, x₂  045 055, x₃  025 0 35, it is required to prov that the system converges to x  0032 0032^3 within 2s.","category":"page"},{"location":"models/Sherlock-Benchmark-7/#Results","page":"3D system with sliding mode controller","title":"Results","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-7/#References","page":"3D system with sliding mode controller","title":"References","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-7/","page":"3D system with sliding mode controller","title":"3D system with sliding mode controller","text":"[YH12]: Dong-Hae Yeom and Young Hoon Joo. Control Lyapunov function design by      cancelling input singularity..      International Journal of Fuzzy Logic and Intelligent Systems, 12, 06 2012.","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Sherlock-Benchmark-9-TORA/Sherlock-Benchmark-9-TORA.jl\"","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/#Translational-Oscillations-by-a-Rotational-Actuator-(TORA)","page":"Translational Oscillations (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"(Image: )","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"using NeuralNetworkAnalysis, MAT\nusing NeuralNetworkAnalysis: UniformAdditivePostprocessing, SingleEntryVector,\n                             NoSplitter","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"The following option determines whether the verification settings should be used or not. The verification settings are chosen to show that the safety property is satisfied. Concretely we split the initial states into small chunks and run many analyses.","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"const verification = false;\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"This model consists of a cart attached to a wall with a spring. The cart is free to move on a friction-less surface. The car has a weight attached to an arm, which is free to rotate about an axis. This serves as the control input to stabilize the cart at x = 0.","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/#Model","page":"Translational Oscillations (TORA)","title":"Model","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"The model is four dimensional, given by the following equations:","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"left beginarraylcl\n      dotx_1 = x_2 \n      dotx_2 = -x_1 + 01 sin(x_3) \n      dotx_3 = x_4  \n      dotx_4 = u\nendarray right","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"A neural network controller was trained for this system. The trained network has 3 hidden layers, with 100 neurons in each layer (i.e., a total of 300 neurons). Note that the output of the neural network f(x) needs to be normalized in order to obtain u, namely u = f(x) - 10. The sampling time for this controller is 1s.","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"@taylorize function TORA!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, u = x\n\n    aux = 0.1 * sin(x₃)\n    dx[1] = x₂\n    dx[2] = -x₁ + aux\n    dx[3] = x₄\n    dx[4] = u\n    dx[5] = zero(u)\n    return dx\nend\n\npath = @modelpath(\"Sherlock-Benchmark-9-TORA\", \"controllerTora.mat\")\ncontroller = read_nnet_mat(path, act_key=\"act_fcns\");\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/#Specification","page":"Translational Oscillations (TORA)","title":"Specification","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"The verification problem is safety. For an initial set of x_1  06 07, x_2  07 06, x_3  04 03, and x_4  05 06, the system has to stay within the box x  2 2^4 for a time window of 20s.","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"X₀ = Hyperrectangle(low=[0.6, -0.7, -0.4, 0.5], high=[0.7, -0.6, -0.3, 0.6])\nU = ZeroSet(1)\n\nvars_idx = Dict(:state_vars=>1:4, :control_vars=>5)\nivp = @ivp(x' = TORA!(x), dim: 5, x(0) ∈ X₀ × U)\n\nperiod = 1.0  # control period\ncontrol_postprocessing = UniformAdditivePostprocessing(-10.0)  # control postprocessing\n\nprob = ControlledPlant(ivp, controller, vars_idx, period;\n                       postprocessing=control_postprocessing)\n\n# Safety specification\nT = 20.0  # time horizon\nT_warmup = 2 * period  # shorter time horizon for dry run\nT_reach = verification ? T : T_warmup  # shorter time horizon if not verifying\n\nsafe_states = HPolyhedron([HalfSpace(SingleEntryVector(1, 5, 1.0), 2.0),\n                           HalfSpace(SingleEntryVector(1, 5, -1.0), 2.0),\n                           HalfSpace(SingleEntryVector(2, 5, 1.0), 2.0),\n                           HalfSpace(SingleEntryVector(2, 5, -1.0), 2.0),\n                           HalfSpace(SingleEntryVector(3, 5, 1.0), 2.0),\n                           HalfSpace(SingleEntryVector(3, 5, -1.0), 2.0),\n                           HalfSpace(SingleEntryVector(4, 5, 1.0), 2.0),\n                           HalfSpace(SingleEntryVector(4, 5, -1.0), 2.0)])\npredicate = X -> X ⊆ safe_states;\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/#Results","page":"Translational Oscillations (TORA)","title":"Results","text":"","category":"section"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"alg = TMJets(abstol=1e-10, orderT=8, orderQ=3)\nalg_nn = Ai2()\nif verification\n    splitter = BoxSplitter([4, 4, 3, 5])\nelse\n    splitter = NoSplitter()\nend\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # We solve the controlled system:\n    silent || println(\"flowpipe construction\")\n    res_sol = @timed sol = solve(prob, T=T, alg_nn=alg_nn, alg=alg,\n                                 splitter=splitter)\n    sol = res_sol.value\n    silent || print_timed(res_sol)\n\n    # Next we check the property for an overapproximated flowpipe:\n    silent || println(\"property checking\")\n    solz = overapproximate(sol, Zonotope)\n    res_pred = @timed predicate(solz)\n    silent || print_timed(res_pred)\n    if res_pred.value\n        silent || println(\"The property is satisfied.\")\n    else\n        silent || println(\"The property may be violated.\")\n    end\n    return solz\nend\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T_reach)  # benchmark\nsol = res.value\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"We also compute some simulations:","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"import DifferentialEquations\n\nprintln(\"simulation\")\nres = @timed simulate(prob, T=T; trajectories=10, include_vertices=true)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"Finally we plot the results","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"using Plots\nimport DisplayAs\n\nfunction plot_helper(fig, vars)\n    if vars[1] == 0\n        safe_states_projected = project(safe_states, [vars[2]])\n        time = Interval(0, T)\n        safe_states_projected = cartesian_product(time, safe_states_projected)\n    else\n        safe_states_projected = project(safe_states, vars)\n    end\n    plot!(fig, safe_states_projected, color=:lightgreen, lab=\"safe states\")\n    if !verification && 0 ∉ vars\n        plot!(fig, project(X₀, vars), lab=\"X₀\")\n    end\n    plot!(fig, sol, vars=vars, color=:yellow, lab=\"\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    fig = DisplayAs.Text(DisplayAs.PNG(fig))\nend\n\nvars = (1, 2)\nfig = plot(xlab=\"x₁\", ylab=\"x₂\")\nfig = plot_helper(fig, vars)\n# savefig(\"TORA-x1-x2.png\")\nfig","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars = (1, 3)\nfig = plot(xlab=\"x₁\", ylab=\"x₃\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars = (1, 4)\nfig = plot(xlab=\"x₁\", ylab=\"x₄\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(2, 3)\nfig = plot(xlab=\"x₂\", ylab=\"x₃\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(2, 4)\nfig = plot(xlab=\"x₂\", ylab=\"x₄\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(3, 4)\nfig = plot(xlab=\"x₃\", ylab=\"x₄\")\nfig = plot_helper(fig, vars)\n# savefig(\"TORA-x3-x4.png\")\nfig","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars = (0, 1)\nfig = plot(xlab=\"t\", ylab=\"x₁\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(0, 2)\nfig = plot(xlab=\"t\", ylab=\"x₂\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(0, 3)\nfig = plot(xlab=\"t\", ylab=\"x₃\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"vars=(0, 4)\nfig = plot(xlab=\"t\", ylab=\"x₄\")\nplot_helper(fig, vars)","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"Here we plot the control functions for each run:","category":"page"},{"location":"models/Sherlock-Benchmark-9-TORA/","page":"Translational Oscillations (TORA)","title":"Translational Oscillations (TORA)","text":"tdom = range(0, 20, length=length(controls(sim, 1)))\nfig = plot(xlab=\"t\", ylab=\"u\")\n[plot!(fig, tdom, [c[1] for c in controls(sim, i)], lab=\"\") for i in 1:length(sim)]\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Cart-Pole/Cart-Pole.jl\"","category":"page"},{"location":"models/Cart-Pole/#Nonlinear-Cart-Pole","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"","category":"section"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"(Image: )","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"The model is a version of the cart-pole introduced by Barto, Sutton, and Anderson in [1].","category":"page"},{"location":"models/Cart-Pole/#Model","page":"Nonlinear Cart-Pole","title":"Model","text":"","category":"section"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"The dynamics of the cart-pole system are described as follows:","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"beginaligned\nddotx = dfracu + mlω^2sin(θ)m_t - dfracml(g sin(θ)- cos(θ))\n            (dfracu + mlω^2sin(θ)m_t)l(dfrac43 - dfracm cos(θ)^2m_t)\n            dfraccos(θ)m_t    \nddotθ = dfrac(g sin(θ)- cos(θ))(dfracu + mlω^2sin(θ)m_t)l(dfrac43\n            - dfracm cos(θ)^2m_t) dfraccos(θ)m_t\nendaligned","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"where u  1010 is the input force, which either pushes the cart left or right, g = 98 is gravity, m = 01 is the pole’s mass, l = 05 is half the pole’s length , m_t = 11 is the total mass, x is the position of the cart, θ is the angle of the pendulum with respect to the positive y-axis, v = dotx is the linear velocity of the cart, and ω = dotθ is the angular velocity of the pendulum. The controller has four inputs (x dotx theta dottheta), four layers with 24 48 12 2 neurons respectively, and two outputs. The two outputs are then compared, and the input sent to the plant depends on which output index has the greatest value.  Thus, as an example if textrmoutput_1  textrmoutput_2 then the input force supplied to the plant is 10.  However if textrmoutput_1  textrmoutput_2 then the input supplied to the plant is -10.","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"using NeuralNetworkAnalysis\n\n@taylorize function cartpole!(du, u, p, t)\n    local f, m, l, mt, g = 10, 0.1, 0.5, 1.1, 9.8\n    sinθ = sin(u[3])\n    cosθ = cos(u[3])\n    aux = (f + m*l*u[4]^2*sinθ) / mt\n    aux2 = l*(4/3 - m*cosθ^2/mt)\n    aux3 = (g*sinθ- cosθ) * aux / aux2\n    aux4 = cosθ/mt\n    aux5 = m*l*aux3\n\n    du[1] = u[2]\n    du[2] = aux - aux5 * aux4\n    du[3] = u[4]\n    du[4] = aux3 * aux4\n\n    return du\nend","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"define the initial-value problem","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"X₀ = Hyperrectangle(low=[-0.05, -0.05, -0.05, -0.05], high=[0.05, 0.05, 0.05, 0.05])\n\nprob = @ivp(x' = cartpole!(x), dim: 4, x(0) ∈ X₀)","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"solve it","category":"page"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"# sol = solve(prob, T=1.0, alg=TMJets(maxsteps=20_000, abstol=1e-10));\nnothing #hide","category":"page"},{"location":"models/Cart-Pole/#Specifications","page":"Nonlinear Cart-Pole","title":"Specifications","text":"","category":"section"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"For this benchmark, the verification objective is to demonstrate that the pole will eventually reach the upward position and that it will remain there.  In other words, the goal is to achieve a value of θ = 0 and stay there.  Some other specifications to be met are, for at least 12 seconds, x  -2424 and θ  -1515 degrees. The initial conditions for all state variables were chosen uniformly at random between -005 005.","category":"page"},{"location":"models/Cart-Pole/#Results","page":"Nonlinear Cart-Pole","title":"Results","text":"","category":"section"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"using MAT\npath = joinpath(@modelpath(\"Cart-Pole\", \"CartPole_Controller.mat\"))\ncontroller = read_nnet_mat(path, key=\"controller\")","category":"page"},{"location":"models/Cart-Pole/#References","page":"Nonlinear Cart-Pole","title":"References","text":"","category":"section"},{"location":"models/Cart-Pole/","page":"Nonlinear Cart-Pole","title":"Nonlinear Cart-Pole","text":"[BSA83]: A. G. Barto, R. S. Sutton, and C. W. Anderson. Neuronlike adaptive       elements that can solve difficult learning control problems.       IEEE Transactions on Systems, Man, and Cybernetics, SMC-13(5):834–846,       Sep. 1983.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/ACC/ACC.jl\"","category":"page"},{"location":"models/ACC/#Adaptive-Cruise-Controller-(ACC)","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"(Image: )","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"The Adaptive Cruise Control (ACC) benchmark is a system that tracks a set velocity and maintains a safe distance from a lead vehicle by adjusting the longitudinal acceleration of an ego vehicle. The neural network computes optimal control actions while satisfying safe distance, velocity, and acceleration constraints.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"using NeuralNetworkAnalysis, MAT\nusing NeuralNetworkAnalysis: FunctionPreprocessing","category":"page"},{"location":"models/ACC/#Model","page":"Adaptive Cruise Controller (ACC)","title":"Model","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"For this case study, the ego car is set to travel at a set speed v_set = 30 and maintains a safe distance D_safe from the lead car.  The car’s dynamics are described as follows:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"left beginarraylcl\ndotx_lead(t) = v_lead(t) \ndotv_lead(t) = gamma_lead(t) \ndotgamma_lead(t) = -2gamma_lead(t) + 2a_lead(t) - uv_lead^2(t)  \ndotx_ego(t) = v_ego(t) \ndotv_ego(t) = gamma_ego(t) \ndotgamma_ego(t) = -2gamma_ego(t) + 2a_ego(t) - uv_ego^2(t)\nendarray right","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"where x_i is the position, v_i is the velocity, γ_i is the acceleration of the car, a_i is the acceleration control input applied to the car, and u = 00001 is the friction parameter, where i  ego lead. For this benchmark we are given four neural network controllers with 3, 5, 7, and 10 hidden layers of 20 neurons each, but only evaluate the controller with 5 hidden layers. All of them have the same number of inputs (v_set T_gap v_ego D_rel v_rel) and one output (a_ego).","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"const u = 0.0001  # friction parameter\nconst a_lead = -2.0  # acceleration control input applied to the lead vehicle\n\n@taylorize function ACC!(dx, x, p, t)\n    v_lead = x[2]  # lead car velocity\n    γ_lead = x[3]  # lead car acceleration\n    v_ego = x[5]  # ego car velocity\n    γ_ego = x[6]  # ego car acceleration\n    a_ego = x[7]  # ego car acceleration control input\n\n    # lead car dynamics\n    dx[1] = v_lead\n    dx[2] = γ_lead\n    dx[3] = 2 * (a_lead - γ_lead) - u * v_lead^2\n\n    # ego car dynamics\n    dx[4] = v_ego\n    dx[5] = γ_ego\n    dx[6] = 2 * (a_ego - γ_ego) - u * v_ego^2\n    dx[7] = zero(a_ego)\n    return dx\nend","category":"page"},{"location":"models/ACC/#Specification","page":"Adaptive Cruise Controller (ACC)","title":"Specification","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"The uncertain initial condition is:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"x_lead(0)  90 110 v_lead(0)  32 322","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":", γ_lead(0) = γ_ego(0) = 0 v_ego(0)  30 302 x_ego  10 11","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"The controller input is (v_set T_gap v_ego x_lead - x_ego v_lead - v_ego). To extract from the current state the last three inputs to the network we define a projection matrix M.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"The verification objective of this system is that given a scenario where both cars are driving safely, the lead car suddenly slows down with a_lead = -2. We want to check whether there is a collision in the following 5 seconds. A control period of 0.1 seconds is used.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"Formally, the safety specification can be expressed as:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"    D_rel = x_lead - x_ego  D_safe","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"where D_safe = D_default + T_gap * v_ego, T_gap = 14 sec, and D_default = 10. After substitution, the specification reduces to: x_lead - x_ego - T_gap * v_ego  D_default.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"# We choose the controller with 5 hidden layers.\ncontroller = read_nnet_mat(@modelpath(\"ACC\", \"controller_5_20.mat\");\n                           act_key=\"act_fcns\");\n\n# The initial states according to the specification are:\nX₀ = Hyperrectangle(low=[90, 32, 0, 10, 30, 0],\n                    high=[110, 32.2, 0, 11, 30.2, 0])\nU₀ = ZeroSet(1);\n\n# The system has 6 state variables and 1 control variable:\nvars_idx = Dict(:state_vars=>1:6, :control_vars=>7)\nivp = @ivp(x' = ACC!(x), dim: 7, x(0) ∈ X₀ × U₀)\nperiod = 0.1;  # control period\n\n# Preprocessing function for the network input:\nv_set = 30.0  # ego car's set speed\nT_gap = 1.4\nM = zeros(3, 6)\nM[1, 5] = 1.0\nM[2, 1] = 1.0\nM[2, 4] = -1.0\nM[3, 2] = 1.0\nM[3, 5] = -1.0\nfunction preprocess(X::LazySet)  # version for set computations\n    Y1 = Singleton([v_set, T_gap])\n    Y2 = linear_map(M, X)\n    return cartesian_product(Y1, Y2)\nend\nfunction preprocess(X::AbstractVector)  # version for simulations\n    Y1 = [v_set, T_gap]\n    Y2 = M * X\n    return vcat(Y1, Y2)\nend\ncontrol_preprocessing = FunctionPreprocessing(preprocess)\n\nprob = ControlledPlant(ivp, controller, vars_idx, period;\n                       preprocessing=control_preprocessing);\n\n# Safety specification\nT = 5.0  # time horizon\n\nD_default = 10.0\nd_rel = [1.0, 0, 0, -1, 0, 0, 0]\nd_safe = [0, 0, 0, 0, T_gap, 0, 0]\n\nd_prop = d_rel - d_safe\nsafe_states = HalfSpace(-d_prop, -D_default)\npredicate = X -> X ⊆ safe_states;\nnothing #hide","category":"page"},{"location":"models/ACC/#Results","page":"Adaptive Cruise Controller (ACC)","title":"Results","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"To integrate the ODE, we use the Taylor-model-based algorithm:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"alg = TMJets(abstol=1e-6, orderT=6, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"To propagate sets through the neural network, we use the Ai2 algorithm:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"alg_nn = Ai2()\n\n\nfunction benchmark(; silent::Bool=false)\n    # We solve the controlled system:\n    silent || println(\"flowpipe construction\")\n    res_sol = @timed solve(prob, T=T, alg_nn=alg_nn, alg=alg)\n    sol = res_sol.value\n    silent || print_timed(res_sol)\n\n    # Next we check the property for an overapproximated flowpipe:\n    silent || println(\"property checking\")\n    solz = overapproximate(sol, Zonotope)\n    res_pred = @timed predicate(solz)\n    silent || print_timed(res_pred)\n    if res_pred.value\n        silent || println(\"The property is satisfied.\")\n    else\n        silent || println(\"The property may be violated.\")\n    end\n    return solz\nend\n\nbenchmark(silent=true)  # warm-up\nres = @timed benchmark()  # benchmark\nsol = res.value\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"We also compute some simulations:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"import DifferentialEquations\n\nprintln(\"simulation\")\nres = @timed simulate(prob, T=T, trajectories=10, include_vertices=true)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"Finally we plot the results:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Controller (ACC)","title":"Adaptive Cruise Controller (ACC)","text":"using Plots\nimport DisplayAs\n\nfig = plot(leg=(0.4, 0.3))\nxlabel!(fig, \"time\")\nF = flowpipe(sol)\n\nfp_rel = linear_map(Matrix(d_rel'), F)\noutput_map_rel = d_rel\n\nfp_safe = affine_map(Matrix(d_safe'), [D_default], F)\noutput_map_safe = vcat([D_default], d_safe)\n\nplot!(fig, fp_rel, vars=(0, 1), c=:red, alpha=.4)\nplot!(fig, fp_safe, vars=(0, 1), c=:blue, alpha=.4)\n\nplot_simulation!(fig, sim; output_map=output_map_rel, color=:red, lab=\"Drel\")\nplot_simulation!(fig, sim; output_map=output_map_safe, color=:blue, lab=\"Dsafe\")\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(\"ACC.png\")\nfig","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/VertCAS/VertCAS.jl\"","category":"page"},{"location":"models/VertCAS/#Vertical-Collision-Avoidance-(VCAS)","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"","category":"section"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"(Image: )","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"This example [1, 2] considers commercial aircraft, which are required to operate with a collision avoidance system that gives vertical climbrate advisories to pilots to prevent near midair collisions (NMACs). An NMAC occurs when the aircraft are separated by less than 100 ft vertically and 500 ft horizontally.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"using NeuralNetworkAnalysis, LinearAlgebra","category":"page"},{"location":"models/VertCAS/#Model","page":"Vertical Collision Avoidance (VCAS)","title":"Model","text":"","category":"section"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"This benchmark is a closed-loop variant of aircraft collision avoidance system ACAS X. The scenario involves two aircraft, the ownship and the intruder, where the ownship is equipped with a collision avoidance system referred to as VerticalCAS [3]. VerticalCAS once every second issues vertical climbrate advisories to the ownship pilot to avoid a near mid-air collision (NMAC), a region where the ownship and intruder are separated by less than 100ft vertically and 500ft horizontally. The ownship (black) is assumed to have a constant horizontal speed, and the intruder (red) is assumed to follow a constant horizontal trajectory towards ownship, see Figure 1. The current geometry of the system is described by","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"h(ft)\n: Intruder altitude relative to ownship\ndot h_0 (ftmin)\n: Ownship vertical climbrate\nτ(s)\n: the seconds until the ownship (black) and intruder (red) are no longer horizontally separated","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"We can, therefore, assume that the intruder is static and the horizontal separation tau decreases by one each second. There are 9 advisories and each of them instructs the pilot to accelerate until the vertical climbrate of the ownship complies with the advisory:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"COC: Clear of Conflict\nDNC: Do Not Climb\nDND: Do Not Descend\nDES1500: Descend at least 1500 ft/min\nCL1500: Climb at least 1500 ft/min\nSDES1500: Strengthen Descent to at least 1500 ft/min\nSCL1500: Strengthen Climb to at least 1500 ft/min\nSDES2500: Strengthen Descent to at least 2500 ft/min\nSCL2500: Strengthen Climb to at least 2500 ft/min","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"In addition to the parameters describing the geometry of the encounter, the current state of the system stores the advisory adv issued to the ownship at the previous time step. VerticalCAS is implemented as nine ReLU networks N_i, one for each (previous) advisory, with three inputs (hdoth_0tau), five fully-connected hidden layers of 20 units each, and nine outputs representing the score of each possible advisory. Therefore, given a current state (hdoth_0tautextadv), the new advisory adv is obtained by computing the argmax of the output of N_textadv on (hdoth_0tau). Given the new advisory, if the current climbrate does not comply with it, the pilot can choose acceleration ddoth_0 from the given set:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"COC: -fracg8 0 fracg8\nDNC: -fracg3 -frac7g24 -fracg4\nDND: fracg4 frac7g24 fracg3\nDES1500: -fracg3 -frac7g24 -fracg4\nCL1500: fracg4 frac7g24 fracg3\nSDES1500: -fracg3\nSCL1500: fracg3\nSDES2500: -fracg3\nSCL2500: fracg3","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"where g represents the gravitational constant 322  textfts^2. If the new advisory is COC(1), then it can be any acceleration from the set g8 0 g8. For all remaining advisories, if the previous advisory coincides with the new one and the current climb rate complies with the new advisory (e.g., doth_0 is non-positive for DNC and doth_0  1500 for CL1500) the acceleration `\\ddot{h}_0$ is 0.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"Given the current system state (hdoth_0tautextadv), the new advisory textadv and the acceleration ddoth_0, the new state of the system (h(t+1)doth_0(t+1)tau(t+1)textadv(t+1)) can be computed as follows:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"beginaligned\nh(t+1) = h - doth_0 Deltatau - 05 ddoth_0 Deltatau^2 \ndoth_0(t+1) = doth_0 + ddoth_0 Deltatau \ntau(t+1) = tau - Deltatau \ntextadv(t+1) = textadv\nendaligned","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"where Deltatau=1.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"const g = 32.2  # gravitational constant\n\n# accelerations (middle)\nconst ACC_MIDDLE = Dict(:COC => 0.0, :DNC => -7g/24, :DND => 7g/24,\n                        :DES1500 => -7g/24, :CL1500 => 7g/24, :SDES1500 => -g/3,\n                        :SCL1500 => g/3, :SDES2500 => -g/3, :SCL2500 => g/3)\n\n# continuous dynamics matrix (h, hdot0)\nconst Δτ = 1.0\nconst A = [1  -Δτ; 0  1.];\nnothing #hide","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"We load the controllers in a dictionary with the keys being the advisories.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"CONTROLLERS = Dict{Symbol, Any}()\n\nCTRL_IDX = [:COC, :DNC, :DND, :DES1500,\n            :CL1500, :SDES1500, :SCL1500,\n            :SDES2500, :SCL2500]\n\npath = @modelpath(\"VertCAS\", \"\")\nfor i = 1:9\n    file = joinpath(path, \"VertCAS_noResp_pra0$(i)_v9_20HU_200.nnet\")\n    adv = CTRL_IDX[i]\n    CONTROLLERS[adv] = read_nnet(file)\nend\n\n\nstruct State{T, N}\n    state::T # state for (h, hdot0) variables\n    τ::N\n    adv::Symbol\nend\n\n\nADVISORIES = Dict{Symbol, Any}()\n\n# for every advisory, return a function to check\n# whether the current climbrate complies with the advisory or not\n# if the advisory *does not* comply => it is changed according to the ACC dictionary\n# otherwise, the new acceleration is zero\nusing Symbolics\n@variables x\n\nADVISORIES[:COC] = EmptySet(1)\nADVISORIES[:DNC] = HalfSpace(x <= 0)\nADVISORIES[:DND] = HalfSpace(x >= 0)\nADVISORIES[:DES1500] = HalfSpace(x <= -1500)\nADVISORIES[:CL1500] = HalfSpace(x >= 1500)\nADVISORIES[:SDES1500] = HalfSpace(x <= -1500)\nADVISORIES[:SCL1500] = HalfSpace(x >= 1500)\nADVISORIES[:SDES2500] = HalfSpace(x <= -2500)\nADVISORIES[:SCL2500] = HalfSpace(x >= 2500)\n\n# this function receives X = [h, hdot0, τ, adv′] and the\n# *previous* advisory adv\nfunction get_acceleration(X::State, adv; ACC=ACC_MIDDLE)\n\n    # obtain projection on hdot\n    hdot = _interval(X.state, 2)\n\n    # transform units from ft/s to ft/min\n    hdot = 60 * hdot\n\n    # new advisory\n    adv′ = X.adv\n\n    # check whether the current state complies with the advisory\n    comply = hdot ⊆ ADVISORIES[adv′]\n\n    if adv == adv′ && comply\n        return 0.0\n    else\n        return ACC[adv′]\n    end\nend\n\nconst normalization_additive = -[0.0, 0, 20]\nconst normalization_multiplicative = 1.0 ./ [16000.0, 5000, 40]\n\nfunction normalize(x::AbstractVector)\n    y = x .+ normalization_additive\n    z = y .* normalization_multiplicative\n    return z\nend\n\nfunction normalize(X::AbstractZonotope)\n    Y = minkowski_sum(X, Singleton(normalization_additive))\n    Z = linear_map(diagm(normalization_multiplicative), Y)\n    return Z\nend\n\n# scalar case; alg is ignored\nfunction forward_adv(X::Singleton, τ, adv; alg=nothing)\n    v = vcat(element(X), τ)\n    v = normalize(v)\n    u = forward(CONTROLLERS[adv], v)\n    imax = argmax(u)\n    return CTRL_IDX[imax]\nend\n\n# set-based case\nfunction forward_adv(X::AbstractZonotope, τ, adv; alg=Ai2())\n    Y = cartesian_product(X, Singleton([τ]))\n\n    Y = normalize(Y)\n    out = forward_network(alg, CONTROLLERS[adv], Y)\n\n    imax = argmax(high(out))\n    return CTRL_IDX[imax]\nend\n\nfunction VCAS!(out::Vector{State{T, N}}, KMAX; ACC=ACC_MIDDLE, alg_nn=Ai2()) where {T, N}\n\n    # unpack initial state\n    X0 = first(out)\n    S = X0.state\n    τ = X0.τ\n    adv = X0.adv\n\n    # get initial acceleration\n    hddot = ACC[adv]\n\n    for i in 1:KMAX\n        # compute next state\n        b = [-hddot*Δτ^2 / 2, hddot * Δτ]\n        S′ = affine_map(A, S, b)\n        τ′ = τ - 1\n        adv′ = forward_adv(S′, τ′, adv, alg=alg_nn)\n\n        # store new state\n        X′ = State(S′, τ′, adv′)\n        push!(out, X′)\n\n        # get acceleration from network\n        # this logic only works for ACC_MIDDLE\n        hddot = get_acceleration(X′, adv; ACC=ACC)\n\n        # update current state\n        S = S′\n        τ = τ′\n        adv = adv′\n    end\n    return out\nend;\nnothing #hide","category":"page"},{"location":"models/VertCAS/#Specifications","page":"Vertical Collision Avoidance (VCAS)","title":"Specifications","text":"","category":"section"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"For this benchmark the aim is to verify that the ownship avoids entering the NMAC zone after k in 1 dots 10 time steps, i.e., h(k)  100 or h(k)  -100, for all possible choices of acceleration by the pilot. The set of initial states considered is as follows: h(0) in -133 -129, doth_0(0) in -195 -225 -255 -285, tau(0) = 25 and textadv(0) = textCOC.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"bad_states = HalfSpace([1.0, 0.0], 100.) ∩ HalfSpace([-1.0, 0.0], 100.)\n\n# property for guaranteed violation\npredicate = X -> X ⊆ bad_states\npredicate_sol = sol -> any(predicate(R) for F in sol for R in F);\nnothing #hide","category":"page"},{"location":"models/VertCAS/#Results","page":"Vertical Collision Avoidance (VCAS)","title":"Results","text":"","category":"section"},{"location":"models/VertCAS/#Simulation","page":"Vertical Collision Avoidance (VCAS)","title":"Simulation","text":"","category":"section"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"const h0 = Interval(-133, -129)\nconst hdot0 = [-19.5,-22.5, -25.5, -28.5]\nconst τ0 = 25.0\nconst adv0 = :COC\n\nfunction _random_states(k=1, include_vertices::Bool=false, rand_h0::Bool=true)\n    N = Float64\n    T = Singleton{N, Vector{N}}\n    states = Vector{State{T, N}}()\n    xs = sample(h0, k, include_vertices=include_vertices)\n    for x in xs\n        if rand_h0\n            # use a random value for y\n            y = hdot0[rand(1:4)]\n            S0 = State(Singleton([x[1], y]), τ0, adv0)\n            push!(states, S0)\n            continue\n        end\n        # use all possible values for y\n        for i in 1:4\n            y = hdot0[i]\n            S0 = State(Singleton([x[1], y]), τ0, adv0)\n            push!(states, S0)\n        end\n    end\n    return states\nend\n\nfunction _all_states()\n    S0 = [convert(Zonotope, concretize(h0 × Singleton([hdot0[i]]))) for i in 1:4]\n    return [State(S0i, τ0, adv0) for S0i in S0]\nend\n\nfunction simulate_VCAS(X0::State; KMAX=10)\n    out = [X0]\n    sizehint!(out, KMAX+1)\n\n    VCAS!(out, KMAX, ACC=ACC_MIDDLE)\n    return out\nend\n\n# project onto the h variable\nfunction _project(X::Vector{State{T, N}}) where {T<:Singleton, N}\n    return [Singleton([Xi.state.element[1], Xi.τ]) for Xi in X]\nend\n\n_interval(X::LazySet, i) = overapproximate(Projection(X, (i,)), Interval)\n\nfunction _project(X::Vector{State{T, N}}) where {T<:Zonotope, N}\n    Xint = [_interval(Xi.state, 1) × Singleton([Xi.τ]) for Xi in X]\nend\n\nfunction run(X0)\n    ensemble = [simulate_VCAS(X0i) for X0i in X0]\n    res = _project.(ensemble)\n    return res\nend\n\nfunction check(sol)\n    println(\"property checking\")\n    res_pred = @timed predicate_sol(sol)\n    print_timed(res_pred)\n    if res_pred.value\n        println(\"The property is violated.\")\n    else\n        println(\"The property may be satisfied.\")\n    end\nend;\nnothing #hide","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"Simulation result for random choice of velocity:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"X0 = _random_states(10, true, false)  # randomly sampled points (incl. vertices)\nprintln(\"$(length(X0)) simulations with central advisories\")\nres = @timed begin\n    res1 = run(X0)\n    check(res1)\nend\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"Simulation result for all choices of velocity:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"println(\"flowpipe construction (unsound) with central advisories\")\nres = @timed begin\n    res2 = run(_all_states())\n    check(res1)\nend\nprintln(\"total analysis time\")\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"Finally we plot the results:","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"using Plots\nimport DisplayAs\n\nfunction plot_helper()\n    fig = plot(xlims=(-200, 200), ylims=(14, 26), xlab=\"h (vertical distance)\",\n               ylab=\"τ (time to reach horizontally)\")\n    plot!(fig, bad_states, alpha=0.2, c=:red, lab=\"unsafe states\")\n    return fig\nend\n\nfig = plot_helper()\nfor o in res1\n    plot!(fig, o, alpha=1.0)\nend\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(\"VertCAS-rand.png\")\nfig","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"fig = plot_helper()\nfor (i, c) in [(1, :blue), (2, :orange), (3, :green), (4, :cyan)]\n    [plot!(fig, o, lw=2.0, alpha=1., markershape=:none, seriestype=:shape, c=c) for o in res2[i]]\nend\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(\"VertCAS-sets.png\")\nfig","category":"page"},{"location":"models/VertCAS/#References","page":"Vertical Collision Avoidance (VCAS)","title":"References","text":"","category":"section"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"[1] Julian, K. D., & Kochenderfer, M. J. (2019). A reachability method for verifying dynamical systems with deep neural network controllers. arXiv preprint arXiv:1903.00520.","category":"page"},{"location":"models/VertCAS/","page":"Vertical Collision Avoidance (VCAS)","title":"Vertical Collision Avoidance (VCAS)","text":"[2] Akintunde, M. E., Botoeva, E., Kouvaros, P., & Lomuscio, A. (2020, May). Formal Verification of Neural Agents in Non-deterministic Environments. In Proceedings of the 19th International Conference on Autonomous Agents and Multiagent Systems (pp. 25-33).","category":"page"},{"location":"lib/solvers/","page":"Solvers","title":"Solvers","text":"DocTestSetup = :(using NeuralNetworkAnalysis)\nCurrentModule = NeuralNetworkAnalysis","category":"page"},{"location":"lib/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"lib/solvers/#Flowpipe-computation","page":"Solvers","title":"Flowpipe computation","text":"","category":"section"},{"location":"lib/solvers/","page":"Solvers","title":"Solvers","text":"solve","category":"page"},{"location":"lib/solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(prob::AbstractControlProblem, args...; kwargs...)\n\nSolves the controlled problem defined by prob\n\nInput\n\nprob   – controlled problem\n\nAdditional options are passed as arguments or keyword arguments; see the notes below for details. See the online documentation for examples.\n\nOutput\n\nThe solution of a reachability problem controlled by a periodic controller.\n\nNotes\n\nUse the tspan keyword argument to specify the time span; it can be:\na tuple,\nan interval, or\na vector with two components.\nUse the T keyword argument to specify the time horizon; the initial time is then assumed to be zero.\nUse the alg_nn keyword argument to specify the solver for the controller.\nWhile this function is written with a neural-network controlled systems in\n\nmind, the type of the controller is arbitrary, as long as a function forward_network to analyze it is available.\n\n\n\n\n\n","category":"function"},{"location":"lib/solvers/#Trajectory-simulation","page":"Solvers","title":"Trajectory simulation","text":"","category":"section"},{"location":"lib/solvers/","page":"Solvers","title":"Solvers","text":"simulate","category":"page"},{"location":"lib/solvers/#NeuralNetworkAnalysis.simulate","page":"Solvers","title":"NeuralNetworkAnalysis.simulate","text":"simulate(cp::AbstractControlProblem, args...; kwargs...)\n\nSimulate a controlled system for a family of random trajectories.\n\nInput\n\ncp           – controlled problem\ntrajectories – (optional, default: 10) number of simulated trajectories\n\nOutput\n\nAn object of type EnsembleSimulationSolution.\n\nNotes\n\nThis function uses the ensemble simulations feature from DifferentialEquations.jl.\n\n\n\n\n\n","category":"function"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"EditURL = \"https://github.com/JuliaReach/NeuralNetworkAnalysis.jl/blob/master/models/Double-Pendulum/Double-Pendulum.jl\"","category":"page"},{"location":"models/Double-Pendulum/#Double-Inverted-Pendulum","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"","category":"section"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"(Image: )","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"This example consists of a double-link pendulum with equal point masses m at the end of connected mass-less links of length L. Both links are actuated with torques T_1 and T_2 and we assume viscous friction exists with a coefficient of c.","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"using NeuralNetworkAnalysis\nusing NeuralNetworkAnalysis: SingleEntryVector, Specification","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"The following option determines whether the falsification settings should be used or not. The falsification settings are sufficient to show that the safety property is violated. Concretely we start from an initial point and use a smaller time step.","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"const falsification = true;\nnothing #hide","category":"page"},{"location":"models/Double-Pendulum/#Model","page":"Double Inverted Pendulum","title":"Model","text":"","category":"section"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"beginaligned\n2ddot theta_1 + ddot theta_2 cos(theta_2 - theta_1) - ddot theta^2_2 sin(theta_2 - theta_1) - 2 fracgLsintheta_1 + fraccmL^2dottheta_1 = frac1mL^2T_1 \nddot theta_1 cos(theta_2 - theta_1) + ddot theta_2 + ddot theta^2_1 sin(theta_2 - theta_1) - fracgLsintheta_2 + fraccmL^2dottheta_2 = frac1mL^2T_2\nendaligned","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"where θ_1 and θ_2 are the angles that links make with the upward vertical axis. The state is:","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"beginaligned\ntheta_1 theta_2 dot theta_1 dot theta_2\nendaligned","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"The angular velocity and acceleration of the links are denoted with θ_1, θ_2, θ_1 and θ_2 and g is the gravitational acceleration.","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"const m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g/L\nconst mL = m*L^2;\n\n@taylorize function double_pendulum!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, T₁, T₂ = x\n\n    # auxiliary terms\n    Δ12 = x₁ - x₂\n    ★ = cos(Δ12)\n    x3sin12 = x₃^2 * sin(Δ12)\n    x4sin12 = x₄^2 * sin(Δ12) / 2\n    gLsin1 = gL * sin(x₁)\n    gLsin2 = gL * sin(x₂)\n    T1_frac = (T₁ - c * x₃) / (2 * mL)\n    T2_frac = (T₂ - c * x₄) / mL\n    bignum = x3sin12 - ★ * (gLsin1 - x4sin12 + T1_frac) + gLsin2 + T2_frac\n    denom = ★^2 / 2 - 1\n\n    dx[1] = x₃\n    dx[2] = x₄\n    dx[3] = ★ * bignum / (2 * denom) - x4sin12 + gLsin1 + T1_frac\n    dx[4] = - bignum / denom\nend;\nnothing #hide","category":"page"},{"location":"models/Double-Pendulum/#Specification","page":"Double Inverted Pendulum","title":"Specification","text":"","category":"section"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"function DoublePendulum_model(use_less_robust_controller::Bool)\n    net_lr = @modelpath(\"Double-Pendulum\", \"controller_double_pendulum_less_robust.nnet\")\n    net_mr = @modelpath(\"Double-Pendulum\", \"controller_double_pendulum_more_robust.nnet\")\n    controller = read_nnet(use_less_robust_controller ? net_lr : net_mr)\n\n    X₀ = BallInf(fill(1.15, 4), 0.15)\n    if falsification\n        # choose a single point in the initial states (here: the top-most one)\n        if use_less_robust_controller\n            X₀ = Singleton(high(X₀))\n        else\n            X₀ = Singleton(low(X₀))\n        end\n    end\n    U₀ = ZeroSet(2)\n    vars_idx = Dict(:state_vars=>1:4, :control_vars=>5:6)\n    ivp = @ivp(x' = double_pendulum!(x), dim: 6, x(0) ∈ X₀ × U₀)\n\n    period = use_less_robust_controller ? 0.05 : 0.02  # control period\n\n    prob = ControlledPlant(ivp, controller, vars_idx, period)\n\n    # Safety specification: [x[1], x[2], x[3], x[4]] ∈ safe_states for all t\n    if falsification\n        if use_less_robust_controller\n            k = 5\n        else\n            k = 7\n        end\n    else\n        k = 20\n    end\n    T = k * period  # time horizon\n\n    lb = use_less_robust_controller ? -1.0 : -0.5\n    ub = use_less_robust_controller ? 1.7 : 1.5\n    safe_states = HPolyhedron([HalfSpace(SingleEntryVector(1, 6, 1.0), ub),\n                               HalfSpace(SingleEntryVector(1, 6, -1.0), -lb),\n                               HalfSpace(SingleEntryVector(2, 6, 1.0), ub),\n                               HalfSpace(SingleEntryVector(2, 6, -1.0), -lb),\n                               HalfSpace(SingleEntryVector(3, 6, 1.0), ub),\n                               HalfSpace(SingleEntryVector(3, 6, -1.0), -lb),\n                               HalfSpace(SingleEntryVector(4, 6, 1.0), ub),\n                               HalfSpace(SingleEntryVector(4, 6, -1.0), -lb)])\n    predicate = X -> isdisjoint(overapproximate(X, Hyperrectangle),\n                                safe_states)  # sufficient property for guaranteed violation\n    predicate_sol = sol -> any(predicate(R) for F in sol for R in F);\n\n    spec = Specification(T, predicate_sol, safe_states)\n\n    return prob, spec\nend;\nnothing #hide","category":"page"},{"location":"models/Double-Pendulum/#Results","page":"Double Inverted Pendulum","title":"Results","text":"","category":"section"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"import DifferentialEquations\n\nfunction run(use_less_robust_controller::Bool)\n    prob, spec = DoublePendulum_model(use_less_robust_controller)\n\n    alg = TMJets20(abstol=1e-9, orderT=8, orderQ=1)\n    alg_nn = Ai2()\n\n    function benchmark(; silent::Bool=false)\n        # We solve the controlled system:\n        silent || println(\"flowpipe construction\")\n        res_sol = @timed solve(prob, T=spec.T, alg_nn=alg_nn, alg=alg)\n        sol = res_sol.value\n        silent || print_timed(res_sol)\n\n        # Next we check the property for an overapproximated flowpipe:\n        solz = overapproximate(sol, Zonotope)\n        if spec.predicate(solz)\n            silent || println(\"The property is violated.\")\n        else\n            silent || println(\"The property may be satisfied.\")\n        end\n\n        # We also compute some simulations:\n        silent || println(\"simulation\")\n        trajectories = falsification ? 1 : 10\n        res_sim = @timed simulate(prob, T=spec.T, trajectories=trajectories,\n                                  include_vertices=!falsification)\n        sim = res_sim.value\n        silent || print_timed(res_sim)\n\n        return solz, sim\n    end;\n\n    benchmark(silent=true)  # warm-up\n    if use_less_robust_controller\n        println(\"Running analysis with less robust controller\")\n    else\n        println(\"Running analysis with more robust controller\")\n    end\n    res = @timed benchmark()  # benchmark\n    sol, sim = res.value\n    println(\"total analysis time\")\n    print_timed(res)\n\n    return sol, sim, prob, spec\nend;\n\n# pass flag to choose the controller\n# `true`: use a less robust controller\n# `false`: use a more robust controller\n# the choice also influences settings like the period and the specification\nres_true = run(true)\nres_false = run(false);\nnothing #hide","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"Finally we plot the results:","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"using Plots\nimport DisplayAs\n\nfunction plot_helper(fig, vars, sol, sim, prob, spec)\n    safe_states = spec.ext\n    if vars[1] == 0\n        safe_states_projected = project(safe_states, [vars[2]])\n        time = Interval(0, T)\n        safe_states_projected = cartesian_product(time, safe_states_projected)\n    else\n        safe_states_projected = project(safe_states, vars)\n    end\n    plot!(fig, safe_states_projected, color=:lightgreen, lab=\"safe states\")\n    if !falsification && 0 ∉ vars\n        plot!(fig, project(initial_state(prob), vars), lab=\"X₀\")\n    end\n    plot!(fig, sol, vars=vars, color=:yellow, lab=\"\")\n    lab_sim = falsification ? \"simulation\" : \"\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    fig = DisplayAs.Text(DisplayAs.PNG(fig))\nend\n\nvars=(1, 2)\nfig = plot(xlab=\"θ₁\", ylab=\"θ₂\")\nsol, sim, prob, spec = res_true\nif falsification\n    plot!(leg=:topleft)\nend\nxlims!(-0.5, 2.0)\nfig = plot_helper(fig, vars, sol, sim, prob, spec)\n# savefig(\"Double-Pendulum-less-robust-x$(vars[1])-x$(vars[2]).png\")\nfig","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"vars=(3, 4)\nfig = plot(xlab=\"θ₁'\", ylab=\"θ₂'\")\nsol, sim, prob, spec = res_true\nif falsification\n    plot!(leg=:topleft)\nend\nxlims!(-0.7, 1.7)\nylims!(-1.6, 1.5)\nfig = plot_helper(fig, vars, sol, sim, prob, spec)\n# savefig(\"Double-Pendulum-less-robust-x$(vars[1])-x$(vars[2]).png\")\nfig","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"vars=(1, 2)\nfig = plot(xlab=\"θ₁\", ylab=\"θ₂\")\nsol, sim, prob, spec = res_false\nif falsification\n    plot!(leg=:topleft)\nend\nfig = plot_helper(fig, vars, sol, sim, prob, spec)\n# savefig(\"Double-Pendulum-more-robust-x$(vars[1])-x$(vars[2]).png\")\nfig","category":"page"},{"location":"models/Double-Pendulum/","page":"Double Inverted Pendulum","title":"Double Inverted Pendulum","text":"vars=(3, 4)\nfig = plot(xlab=\"θ₁'\", ylab=\"θ₂'\")\nsol, sim, prob, spec = res_false\nif falsification\n    plot!(leg=:topleft)\n    ylims!(-1.0, 1.5)\nelse\n    xlims!(-1.8, 1.5)\n    ylims!(-1.6, 1.5)\nend\nfig = plot_helper(fig, vars, sol, sim, prob, spec)\n# savefig(\"Double-Pendulum-more-robust-x$(vars[1])-x$(vars[2]).png\")\nfig","category":"page"}]
}
